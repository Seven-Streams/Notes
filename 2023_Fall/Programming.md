# 一、绪论

## 1、程序设计概述

程序设计的四个步骤：算法设计，编程，编译和链接，调试与维护。

## 2、计算机组成

加法器、ALL、寄存器。

# 二、程序的基本组成

## 1、程序的基本结构

预编译：包含库包含等指令。

实体均定义在**名字空间**内。

## 2、变量与常量

标识符不能以字母开头。

auto类型说明符的使用。

**decltype**类型指示符。

*用法示例：*

```cpp
int a,b;
decltype(a+b) c;


auto a = 1, b = 2, c = 'A';//不合法。因为auto后定义的变量类型必须一样。
```

这样就可以判断出c的类型为int。

在计算机中，整数加减会使用**补码**。正数补码为其本身。负数补码为其反码再加一。

浮点数内部以科学计数法形式表示。存在截断误差。

十进制小数转化为二进制：十进制小数部分乘2，除以1。

标准ASCII码中一位为校验码。

在输入数字时，最前面加上**0**表示为八进制，加上**0x**表示为十六进制。

bool类型中，0代表false。只要有值，就是true。

后缀加上l/u/ul/ll/ull可以指明数字类型。

字符常量中有一些”非打印常量“。比如‘\n’。

constepr可以定义常量表达式。**编译时**必须是常量。

const则不用。

## 3、数据的输入/输出

```cpp
char a;
cin.get(a);
a = cin.get();//这两种方法可以读入空白字符。
cout << a;
cout.put(a);//这两种输出是等价的。
cout.put(65);//put的形参是一个char，所以输出是'A'。
```

## 4、算术运算

不同类型运算时会发生自动类型转换。

此外还有

```cpp
int x;
static_cast<long long>(x);//静态转换。
reinterpret_cast<>();//重解释转换。比如将指针指向的内容由int解释为char。
const_cast<>();//常量转换。改变常量属性。
dynamic_cast<>();//动态转换。
```

## 5、赋值运算

左值和右值的概念。简单来说，不能被赋值的就是右值。

赋值表达式返回值是所赋的值。

# 三、分支程序设计

## 1、关系表达式

## 2、逻辑表达式

注意：||运算和&&运算存在一个优化。当||左出现true，则不检查||右。&&类似。

## 3、if语句

## 4、switch语句及其运用

# 四、循环程序设计

## 1、计数循环

假设for循环中缺省循环条件，就是死循环。

## 2、break和continue语句

## 3、基于哨兵的循环

## 4、循环的中途退出

## 5、输入异常的检测

```cpp
bool a = cin.eof();//文件结束
a = cin.fail();//输入内容不符合预期
a = cin.bad();//奇奇怪怪的问题
```

## 6、枚举法

## 7、贪婪法

# 五、过程封装——函数

## 1、函数定义

函数包括函数头和函数体。

尾置返回类型：decltype。

```cpp
auto add(int a, int b) -> decltype(a + b) {
    return a + b;
}
```

## 2、函数的使用

函数原型声明。

## 3、变量的作用域

局部变量和全局变量。局部变量仅在局部（如一个分支语句，一个循环语句等）有效。即**作用域**。

## 4、变量的存储类别

```cpp
auto int a;//自动变量。最常见的那种。
static int a = 10;//在局部作用完成后不会消亡。在下一次使用保留上一次使用的终值。
register int a;//寄存器变量。这个优化现在编译器自行完成。
extern int a;//外部变量，可以从其他头文件，或源文件处获取变量。
```

## 5、带默认值的函数

这样的函数可以缺省一部分输入。

```cpp
void add(int a, int b = 10) {
    return a + b;//如果没有输入b，那么b就是10。
}
```

## 6、内联函数

## 7、常量表达式函数

```cpp
costexpr int f1() {
    return 10;
}//在常量表达式函数只能有一个return语句。并且不允许进行其他操作
```

## 8、重载函数

```cpp
int max(int a, int b) {
    return a > b ? a : b;
}
int max(int a, int b, int c) {
    if(a > b) {
    return a > c ? a : c;
    }    else {
        return b > c ? b : c;
    }    
}//即允许拥有相同的函数名。
```

## 9、函数模版

```cpp
template <class T>
T max(T a, T b) {
    return a > b ? a : b;
}


template <class T1, class T2, class T3>
T1 add(T2 a, T3 b) {
    return a + b;
}//计算机不知道T1是什么类型。调用时需要：
add<char, int, char>(5, 'a');//显式实例化。

template<class T> T add(T a, T b) {
    return a + b;
}
//以下是函数模版的特化。
template<> string add(char a, char b) {
    string txt;
    txt += a;
    txt += b;
    return txt;
}
```

函数模版一样可以重载。

## 10、递归函数

# 六、批量数据处理——数组

## 1、一维数组

遍历数组的一种特殊写法

```cpp
int a[10];
for(auto x: a) {
    cin >> x;
}
```

数组可以作为函数参数。数组尽管传值引用，也会改变数组内元素的值。如果在函数形参表中写了"a[]"而非"a[10]"，那么还需要通过其他途径传递数组大小这一信息。

## 2、查找

## 3、排序

## 4、二维数组

二维数组可以用如下方式部分初始化

```cpp
int a[3][4] = {{1, 2}, {3, 4}, {5}};
```

不能使用"a[][]"来使二维数组作为函数参数。**第二个下标**一定要是编译时的常量。如a[][5]是合法的。

## 5、字符串

字符串的结束一定存储了'\0'。也就是说，空字符串占一个字节。

```cpp
char ch[] = "Hello,world";
cin.get(字符数组名,长度,（结束标记）);
cin.getline(同上);
```

这种方式是合法的。

字符数组之间**不能**互相赋值。但是字符串可以。

## 6、基于递归的算法

# 七、间接访问——指针

## 1、指针概述

```cpp
int x, *p;
*p = &x;
```

将x的地址赋予*p。

不同类型指针不能赋值。除非使用reinterpret_cast。

统配指针void。任何类型的指针都可以赋给统配指针。

指针常量

```cpp
const int *p = &x;//这个的意思是*p指向的内容是个常量。不能通过*p改变x。但可以改变p。
int *const p = &x;//这个的意思是*p永远指向&x。但是x是可变的。
const int *const p = &x;//这个指向的地址是不可变的。并且不可通过指针修改x的值。
```

## 2、指针运算与数组

指针可以访问数组。

```cpp
int *p, a[5];
p = a;//这是合法的。
```

## 3、动态内存分配

```cpp
int *p = new int(10);
delete p;
*p = new int[10];
delete [] *p;
```

注意要及时删除动态变量，防止内存泄漏。对于字符串，删除动态变量时可以不添加[]。

## 4、字符串再讨论

## 5、指针与函数

指针可以出现在形参表中。为了方便书写，常直接进行传址。

指针也可以作为返回值。只要在写函数时提前声明。

## 6、引用类型

引用可以给左值取一个别名。

```cpp
int i;
int &j = i;
i = 1;
cout << j;//输出1
j = 2;
cout << i;//输出2
int a;
const int &b = a;//尽管a和b地址相同，想要修改b，只能通过a。
int num[10];
for(int &k : num) cin >> k;//可以输入数组的元素。
```

引用传递

```cpp
int ConvertToInt(const char *&s){
    ;//这样也可以看作是一种特殊的传址引用。
}
```

引用也可以作为返回值。需要注意的是，引用返回时不可以返回值，因为此时值是临时变量，已然被销毁。

```cpp
int a[5];
int &index(int j) {
    return a[j];//返回的是一个地址。
}
```

右值也可以进行引用。需要使用&&。

```cpp
int x = 10;
int &&y = x + 9;
```

这也就意味着，y直接接管了右侧表达式的空间。而不用重新分配空间。

## 7、指针数组与多级指针

```cpp
char *txt[10];//定义了10个字符数组
int x = 15;
int *p = &x;
int **q = &p;
```

main函数可以有两个形式参数。argc和argv[]。argc表示这一次执行时命令行有多少次命令。*argv[i]指向第i个命令。

二维数组也可以动态申请。

```cpp
int **a;
a = new int * [3];
for(int i = 0; i < 3; i++) {
    a[i] = new int [4];
}
for(int i = 0; i < 3; i++) {
    delete [] a[i];
}
delete [] a;
```

## 8、函数指针

指针可以指向一个函数。这个常常用来做菜单界面。

常见的格式如下：

```cpp
void （*func[3])() = {NULL,add,erase};//如此，定义了三个类型为void，且形参表为
//空的函数指针；
int main() {
    int op;
    cin >> op;
    func[op];
    return 0;
}
```

函数指针也可以作为一个函数参数。比较常见的有stl中的自定义排序规则。

lambda表达式：

```cpp
[](int x, int y) -> int { int z = x + y; return z;}//这个可以填在形参表中。
```

中括号中需要填写捕获列表。这里通常留空。

```cpp
[x](int y) -> int {int z = x + y; return z;}//用值传递将函数中的变量x捕获
[&x](int y) -> int {int z = x + y; return z;}//用引用将函数中的变量x捕获
[=]() -> int {int z = x + y; return z;}//用值传递将函数中的所有变量捕获
[&]() -> int {int z = x + y; return z;}//用引用将函数中的所有变量捕获
```

# 八、数据封装——结构体

## 1、结构体

```cpp
(*s).name;
s -> name;//两种表达方式等价
```

## 2、链表

# 九、模块化开发

枚举类型

```cpp
enum test {
    x,y,z;
}//test是一种枚举类型。x取值为0，以此类推。枚举类型的变量可以互相赋值。
test res1,res2;
res1 = x;//相当于把res1设定为0
```

# 十、创建新的类型

## 1、面向对象程序设计

## 2、类的定义

私有成员和公有成员。

私有成员不可为非类内函数访问。

## 3、对象的使用

this指针

## 4、对象的构造与析构

构造函数和析构函数

默认构造函数

缺省值的构造函数

初始化列表

```cpp
DoubleArray::DoubleArray(int lh, int rh): low(lh), high(rh) {
    storage = new double [high - low + 1];
}//这个构造函数的第一行使用了初始化列表。相当于对low，high两个成员进行了赋值。
```

委托构造函数：在构造函数中调用其他构造函数。

拷贝构造函数：不能使用值传递。只能使用常量引用。因为值传递的时候会调用拷贝构造。也可以自定义进行拷贝构造。但**尽量**避免。指针一定要进行自定义拷贝。同时，如果成员有指针，在调用拷贝构造函数时，需要判断是否进行了自引用。

对象定义时，就算使用等号，也不是赋值运算。定义的时候一定调用**构造函数**。

移动构造函数：进行右值引用，直接接管临时变量空间以提高效率。

右值引用不能操作左值！！！

类内初始化

析构函数

对象的生命周期

## 5、const与类

const对象

不修改数据成员的成员函数，那么使用const成员函数。

## 6、静态成员

静态数据成员定义

静态数据成员属于整个类。相当于类的全局变量。

特殊点：静态成员函数没有**this**指针。静态成员函数只能访问静态成员或者其他静态函数。

静态常量数据成员

## 7、 友元

友元函数、友元类、友元成员函数。

友元函数定义可以放在**类内**任何位置。

使用友元成员或是友元类时，需要先对类进行声明。

# 十一、运算符重载

## 1、运算符重载的意义

## 2、运算符重载的方法

实际上也是新写了一个函数。函数名为：

```cpp
operator@//@为需要重载的运算符
```

函数类型显然与运算结果相同。

如果将运算符重载为成员函数，那么第一个参数为this指针指向的对象。

如果将运算符重载为**友元**函数，那么函数参数数目与参与运算的参数数量相同。

大多数运算符既可以重载为成员函数或全局函数。

但是**赋值号=，下标[]，函数调用()，成员访问->** 必须重载为成员函数。

**流插入、流提取**必须重载为全局函数。

一般而言，重载为全局函数会使程序结构更明晰。

## 3、几个特殊运算符的重载

### 赋值号

没有指针时，可以缺省赋值号的重载。此时会进行空间拷贝。

有指针时，我们必须要重载赋值号。在此处，我们应该也需要考虑自赋值的情况。

一般而言，如果有拷贝构造函数，那么也需要重载赋值运算符。

### 移动赋值

实际上，就是对赋值号的临时变量，来进行右值引用。

```cpp
DoubleArray &DoubleArray::operator=(DoubleArray && a) {
    delete [] storage;
    low = a.low;
    high = a.high;
    storage = a.storage;
    a.storage = nullptr;
    return *this;
}
```

### 下标

注意下标运算符重载时需要引用。 

### 函数调用

它是一个二元运算符。第一个运算对象是函数名，第二个是形参表。运算结果是函数的返回值。这可以把类的对象重载成函数名。

### 自增、自减运算符

前缀是一元操作符，而后缀是二元操作符。认为多了一个整型参数。

传递入的整型参数毕竟没有被调用，只是用来区分函数形参表的。

前缀引用返回，而后缀须值返回。

### 输入输出运算符

输出时必须要加上const。这是保证在常量时的正确性。

## 4、自定义类型转换函数

### 内置类型到类类型的转换

```cpp
explicit Rational(int n1 = 0, int n2 = 1);//这样可以禁止隐式自动调用构造函数
```

### 类类型到其他类型的转换

同样使用explicit，禁止自动类型转换。

# 十二、组合和继承

## 1、 组合

将对象作为类的数据成员。  

通常通过初始化列表赋初值。

在组合中，可以**重用**其他部分的代码。也就是说，组合相当于是类中存放了其他类。

## 2、 继承

父类（基类）：被继承的对象。

子类（派生类）

```cpp
class Base
{
private:
...;
public:
...;
};
class Son:public Base
{
    int y;
public:
    void y();
};
```

这种格式，可以进行代码重用，并且扩展代码功能。

派生方法：决定基类成员在派生类中的访问特性。

公有派生：基中的public依旧public。

私有派生：基中的public变为private。

保护派生：基中的public变为protected，只能被派生类和友元访问。

一般而言，公有继承是最常见的派生方式。

protected关键字：保护成员和保护派生。也可以被友元访问。

派生类对象中，**基类**不必再次构造。直接由**基类**的构造函数和析构函数操作。

也就是说，可以直接调用基类中的函数。

如果没有写这一部分，那么就会调用基类的缺省构造函数。

一般而言，先执行基类的构造函数，再次构造派生类的新增部分。

### 重定义基类的函数

如果派生类和基类中有同名函数，那么c++默认调用派生类的函数。

重定义时，函数原型必须一样。

### 派生类对象的赋值

派生类对象可以调用基类赋值运算符重载函数完成基类部分的赋值。

### 派生类作为基类

### 将派生类对象赋值给基类对象

将派生类和基类公有部分赋给基类，派生类新增部分丢弃。

基类指针可以指向派生类。

派生类指针不可以指向基类对象。

## 3、多态性

这可以便于系统功能的扩展。

静态联编和动态联编。

### 虚函数

在虚函数中，会根据指向内容的不同（基类或派生类），决定执行基类中的成员函数还是派生类中的成员函数。无论**指针类型**。

引用和指针是两种非常接近的操作。

override关键字:检查是否正确重定义了函数（函数原型相同）。

final关键字：表示其派生类中禁止覆盖这类函数。

### dynamic_cast

使用在类的继承当中。

基类对象指针可以指向派生类对象，基类对象可以引用派生类对象。

```cpp
class A{
    int a;
};
class B:public A{
    int b;
};
class C:public B{
    int c;
};
A *pa = new B;
C *pc = new C;
//B *pb = pa;是不合法的
```

### 虚析构函数

构造函数不能是虚函数。

但是，析构函数可以是虚函数，而且最好是虚函数。

如果派生类中**新增**的数据成员含有动态对象，如果使用基类指针指向派生类，如果不使用虚函数，调用基类的析构函数就会造成内存泄漏。

建议在根节点时，即将析构函数定义为虚函数。

## 4、抽象类

### 纯虚函数

 virtual 类型  函数名（参数表）= 0；

这就是纯虚函数的声明。

它在该基类中**未定义**。

如果一个类含有纯虚函数，那么称它为**抽象类**。

抽象类作为基类，产生派生类。抽象类不可以作为对象。

# 十三、泛型机制——模板

## 1、类模板的定义与使用

```cpp
template <class T>
class A {
    int a;
    int b;
    T *x;
};
```

使用类模板时，成员函数的定义必须写在同一个函数里。

类模板的实例化。

```cpp
A<int> w;
```

只有在成员函数调用时，类模板的成员函数才会被编译。

或者，使用类模板的显式实例化：

template class 类名<实际参数表>;

非类型形参

## 2、类模板的特化

```cpp
template<> class A<const char *> {};
```

## 3、类模板的友元

既可以是普通的类或者全局函数。

也可以是另外一个模板。

```cpp
template <class type>
class A {
    friend class B;
};//B是所有该类对象的友元。
```

### 类模板作为友元

```cpp
template <class T> class B;
class A {
    friend class B <int>;
};//B模板类中，所有int实例是A的友元。
```

### 约束友元

当模板相同时，是友元。

```cpp
template <class T> class B;
template <class Type> class A {
    friend class B<Type>;//模板实例化对象相同时，是友元。
};
```

### 重载函数模板

注意类模板、函数模板的声明。

### 非约束友元

## 4、类模板的多功能性

类模板也可以作为基类。但是要注意带上模板参数。

### 智能指针

在释放指针本身的空间是，自动调用析构函数析构其指向的对象。

auto_ptr

shared_ptr

unique_ptr

三种智能指针的区别

# 十四、输入/输出与文件

## 1、流与标准库

输入流、输出流

输入输出总共分为三类。分别基于控制台、文件、字符串。

有三类用于I/O的标准库。分别是iostream、fstream、sstream。

类型分别为:

istream、istream、iostream；

ifstream、ofstream、fstream；

istringstream、ostringstream、stringstream。

多继承的概念。

## 2、输入输出缓冲

外围设备$\leftrightarrow$I/O对象$\leftrightarrow$程序

每个I/O对象管理一个缓冲区。

cin语句读入缓冲区的数据。iff缓冲区中没有数据，那么cpu才会停下来等待输入。

### 输出缓冲区的刷新

**1、程序正常结束**

**2、缓冲区满**

**3、强制刷新**

**4、关联输出流与输入流**：cout与cin是关联的。每次使用cin，都会把输出缓冲区的内容cout出来。

## 3、基于控制台的输入/输出

cerr对象与clog对象。

cerr对象与标准错误输出设备相连，无缓冲。

clog类cerr，然有缓冲。

整形数可以使用流操纵符调整整形数的基数。

```cpp
#include<bits/stdc++.h>
cout<<hex<<114514;//十六进制
cout<<oct<<114514;//八进制，也可以使用setbase语句。但是需要注意，只要修改过输出的基
//数，那么此后在不修改的情况下，都会沿袭此进制输出。
```

浮点数的精度也可以设置。

可以使用流操纵符或者成员函数来进行。同上，存在沿袭的情况。

```cpp
cout.precision(8);//将浮点数的精度设置为8
cout<<steprecision(7)<<n;//将浮点数的精度设置为7，并输出n。
```

需要注意的是，如果浮点数整数部分大于设定位数，那么就会使用科学计数法。

如果为了固定小数点，可以使用流操纵符fixed。

类似上面的办法，可以使用成员函数width和流操纵符setw设置宽度。

**值得注意的是，域宽设置的函数仅在本次输出时有效。**

如果实际域宽超出设定域宽，那么使用实际域宽。setw的补齐，会将补齐字符在前面输出。这也意味着，此时对象是右对齐。

左右对齐可以使用流操纵符left、right设置。

showbase：在数字前面输出基数。

(no)upperbase：将十六进制以及科学计数法中的字符用**大写字母**（复位）。

setfill：设置填充字符。

scientic：科学计数法输出浮点数。

showpos：正数前显示加号。

skips：跳过空白字符。

## 4、基于文件的输入/输出

### 文件的概念

#### 外存与内存

外存的访问原理：磁道、柱面与扇区

一次读文件，检查缓存区内是否存在需求的信息。如果没有，发起一次真正的I/O请求，到外存设备中寻找信息。

尽量少访问外存。

### 流式文件

把文件看作一个有序的字节流。最终以EOF为结束标识。

### ASCII文件

文本文件。每个字节解释为一个字符的ASCII。

### 二进制文件

将每个字节看成是一个二进制比特串。

### 文件访问过程

打开文件、访问文件以及关闭文件。

输入文件流：ifstream

输出文件流：ofstream

输入输出文件流：fstream

需要定义一个流对象。可使用open成员函数打开。或者使用构造函数。

**in**：打开文件，读。

**out**：打开文件，写。

**app**：在每次写前，找到文件尾。

**ate**：打开文件后，立即定位在文件尾。

**trunc**：打开文件时，清空。

**binary**：以二进制模式进行输入输出。

若流对象内容为0，那么就说明打开失败辽。

文件关闭时，使用成员函数close。对于输出文件，close会将缓冲区的内容写入文件。

### 文件的顺序访问

二进制文件通常使用read函数和write函数。

">>"的结果为0或者get得到EOF等，可以判断文件是否结束。

```cpp
out.write(reinterpret_cast<char *> (&i), sizeof(int));//write和read
//会进行二进制读写。
```

不必在意这个reinterpret_cast是什么意思。

### 文件的随机访问

文件定位指针：指出当前应该从什么位置开始读写。

通过in（out）打开时，读（写）指针定位在开头。

tellg返回读文件指针值。

tellp返回写文件指针值。

seekg：设置读文件指针值。

seekp：设置写文件指针值。

```cpp
seekp(n);//写文件的指针第n个字节。0-base。
seekg(1,ios::cur);//读文件的指针后移1位
```

通过seekg操作，文件内原本的内容会被**覆盖**。

ASCII文件不适合进行随机修改。

随机读写一般使用二进制文件。

```cpp
fstream io("file",fstream::binary);
int i = 20;
io.seekp(5 * sizeof(int);
io.write(reinterpret_cast<char *>(&i), sizeof(int));
```

# 十五、异常处理

## 1、什么是异常

传统错误的处理方法，就是在发生错误的地方就地处理。

这种方式虽然直观，但是会使得代码结构结构更复杂，降低了可维护性。

## 2、异常处理机制

组成部分包括：异常抛出，异常捕获和异常处理。

```cpp
throw myerror("FUCK");//myerror是自定义的一种类型。抛出了一个myerror的对象
```

将处理错误的代码分开。throw的作用在一定程度上与return的作用相近。

一般而言，异常类可以是一个空类。

异常捕获

```cpp
try{
    ...
}
catch(ErrorType1 a){...}
catch(ErrorType2 b){...}//可以选择性填入a，b这两个参数。因为异常捕获以类型为标志
catch(...){...}//在catch中填入三个点，可以捕获任意类型的异常
```

如果按照传统方式进行函数声明，那么函数可以抛出任何异常。

```cpp
void f() throw();//这表示函数不会有异常抛出。
void f() throw(type1,type14,type51,type4);//这表示函数可能抛出这四种异常。
```

但是，c++11后，不可以这样操作。因为这可以用注释声明，同时为编译器增加了工作量。

c++11后，添加了关键字noexcept，在函数声明时使用。表示这个函数不会抛出异常。

# 十六、容器和迭代器

## 1、容器

容器是保存一组同类数据的类。

容器一般需要提供插入，删除，查找以及访问。

## 2、迭代器

表示其中变量位置的一种类型。指向一个元素。

## 3、数组实现的容器

动态数组

容器类和迭代器类

因为是数组，所以很容易做到重载下标运算符。

可以把迭代器设计成容器的内嵌类。

```cpp
map::iterator a;//定义了一个map的迭代器
```

可以定义一个模板。

## 4、链表实现的容器

结点类，容器类和迭代器类。

需要先申请头结点和尾结点。

容器将内容封装。迭代器实际上就可以理解为一个指针。

# 十七、软件开发

## 软件工程

开发文档

## 软件生命周期

可行性研究、需求分析、总体设计、详细设计、编码及单元测试、综合测试。

可行性研究报告

需求分析

数据精度、响应时间、数据量、并发量

软件开发的说明书

概要设计说明书：

模块结构图及每个模块的功能要求

数据库设计

类设计

详细设计(模块设计)

集成测试

验收测试

## 软件开发实例
