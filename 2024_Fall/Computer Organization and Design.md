# 计算机组成与设计

## 第一章 计算机抽象及相关技术

存储容量的十进制术语和二进制术语的区别：KB, MB, GB 为十进制；KiB, MiB, GiB 为二进制。

计算机体系结构的七个“伟大思想”：

- 使用抽象(abstraction)简化设计

- 加速大概率事件

- 并行提高性能

- 流水线提高性能

- 预测提高性能

- 存储分层

- 冗余提高可靠性

计算机的经典部件：输入设备，输出设备，存储器，数据通路（运算器），控制器。后二部分合称处理器。

RAM名字的由来：访问RAM中各部分的数据，时间基本一致。内存即为DRAM，D表示dynamic；cache则为SRAM,即static.

存储器分为易失性存储器和非易失性存储器。前者称为主存储器或一级存储器。后者称为二级存储器。

Amdahl定律：$t = \frac{a}{k} + a'$，a为被加速部分，k为加速比，$a'$为未加速部分。说明性能优化与整体的关系。

SRAM,DRAM,二级存储器构成了存储器层次(hierarchy of memory)中的三层。

在个人移动设备中，二级存储器常是闪存而非磁盘。

闪存体积小，可靠性好，能耗低，但是一个单元写入1e5至1e6次就可能损坏。

CPI：CPU时间周期数除以指令数。

## 第二章 指令

指令系统(instruction set):指令的词汇表。

JAVA一开始是解释器。如今为了性能，会进行即时编译从而运行。

指令的设计原则1：简单源于规整。要好翻译。

算术运算指令

在RISC-V中，32位称为字，64位称为双字(doubleword)。

指令的设计原则2：更少则更快。指令的操作数如果过多，那么很有可能会增加时钟周期。因为电信号传播耗时增加了。

数据传输指令

计算机分为大端编址和小端编址。大端编址：存储内容的高位存储在高字节中。小端编址则相反。

寄存器比内存显然快得多。并且，内存数据必须先读出。因此寄存器明显有着更高的吞吐率。

立即数操作也可以减少存取指令。RSIC-V有着常零寄存器，方便我们进行操作。

二进制补码(two's complement)

这种存储方式利用的是算术上的溢出。考虑到这一点，我们可以将有符号数用统一的公式表示。即：

$$
x=(x_{31}\times (-2)^{31})+\sum_{i=0}^{30}(x_i\times 2^i)
$$

符号扩展的过程就是在数据左侧填充符号位，正确地表达目标数。有符号载入也是这个过程。

为什么不使用反码？因为计算过程中需要额外的一步去计算。虽然正数和负数是平衡的，但却存在正零和负零。

计算机中的指令表示：二进制机器码。称这种指令的设计为指令格式。在RSIC-V中，指令都为32位长。符合简单源于规整的原则。我们把RISCV指令的每一部分称为一个字段。

一般的RISCV指令组成是：funct(7)+rs2(5)+rs1(5)+funct(3)+rd(5)+opcode(7)

所加的每一项都是指令的一个字段。

设计原则3：优秀的设计需要适当的折中。

上所述为R型指令。考虑到某些指令需要更长的字段，从而有:

- I型：immediate(12)+rs1(5)+funct(3)+rd(5)+opcode(7)

- S型：immediate(11:5)+rs2(5)+rs1(5)+funct(3)+immediate(4:0)+opcode(7)

为什么S型这么奇怪？这是为了保证rs1和rs2在不同指令中处于相同位置，降低硬件设计的复杂性。其他字段亦是同理。

考虑到指令长度与寄存器数量有不可分割的关系，所以大部分架构寄存器数量为16或32个。

逻辑操作

在RSICV中没有取反操作。因为取反等价于和-1取异或。

c++中位字段的使用：

```cpp
//ref:https://blog.csdn.net/wendyWJGU/article/details/134880176

#include <iostream>
using namespace std;

#include <fstream>
struct Data1
{
    unsigned int bit0 : 1;
    unsigned int bit1 : 3;
    unsigned int bit2 : 6;
    unsigned int bit3 : 22;
};

int main()
{  
    unsigned int uSrcData = 0x12345678;

    cout << hex << "\n\nuSrcData = 0x" << uSrcData << endl;
    Data1 d2;
    d2.bit0 = uSrcData >> 31;
    d2.bit1 = (uSrcData >> 28);
    d2.bit2 = (uSrcData >> 22);
    d2.bit3 = (uSrcData);

    cout << hex << "bit0 = 0x" << d2.bit0 << endl;//0x0
    cout << hex << "bit1 = 0x" << d2.bit1 << endl;//0x1
    cout << hex << "bit2 = 0x" << d2.bit2 << endl;//0x8
    cout << hex << "bit3 = 0x" << d2.bit3 << endl;//0x345678
}
```

对位字段进行合适的操作，可以方便地取出无符号数中我们想要的内容。

分支地址表：在数据区存储多分支的起始地址。当遇到多分支结构时，在这部分进行寻址。这样可以减少分支语句数。

计算机硬件对过程的支持：比如ra(x1),a0-a7(x10-x17)这些寄存器。

栈指针sp(x2)

x5-x7及x28-x31为t0-t6

x8-x9及x18-x27为s0-s11

如果一个过程不调用其他的过程，那么我们称这个过程为叶子过程。如果在嵌套过程中，那么我们就需要将必要保存的寄存器进行压栈，调整sp.

x3(gp)的作用：为了简化对静态数据的访问，**部分**RSICV保留x3用作全局指针。

栈也会为局部变量分配空间。我们把保存有寄存器和存储有局部变量的段称为过程帧或者活动记录。有些编译器使用fp(x8)用作帧指针。指向帧的第一个字。如果对sp处理得好也许可以不用这一点。

栈从用户地址空间的高端开始。低端内存的第一部分为保留区。第二部分为代码区。第三部分为静态数据区。第四部分为堆区。也就是说，栈和堆是**相向**生长的，这样有利于对内存的高效利用。C调用malloc和free来分配空间或者释放空间。

RSICV中，栈空间从0x0000 0x3f ffff fff0开始向下；代码从0x0000 0000 0040 0000 开始向上。静态数据区从文本段末开始。

尾调用具有高效的迭代。

ASCII码对人类非常友好。但是java中，为了更有包容性，其默认采用unicode编码。其默认采用16位表示一个字符。riscv保持16字节栈空间对齐。

RSICV中的寻址模式，无非是立即数寻址，寄存器寻址，基址寻址（寄存器加常量）和PC相对寻址四种。条件分支只能到达附近的区域。

### 并行

如果并行执行的任务之间不相互同步，就存在数据竞争的风险。并行机制依赖于硬件提供的同步指令。

在互斥区中的数据，只有单个处理器可以操作。

RSICV中对并行的支持指令：lr.w（保留加载）和sc.w（条件存储）等。这两条指令要顺序使用。也就是先进行保留加载，再进行条件存储。如果保留加载的目标地址，在条件存储执行之前，其中内容发生了变化，那么就不会成功。sc.w有三个寄存器参数。第一个rd用于表征存储成功还是失败，值为1或0。rs1指定存储的内容，rs2指定地址。利用这两个指令，可以实现原子交换。这样的操作可以构建更多的原子操作。要想获得锁变量，我们也需要进行原子的操作。但是，释放的时候就随意了。

### 翻译

首先通过编译器。编译器的作用，就是把高级语言转换为汇编语言。

然后通过汇编器。汇编器的作用是对伪指令进行转换。转换为RISCV中的基本指令,并且生成二进制机器码，生成目标文件。在汇编器中，对符号表和指令位置进行了很好的维护，从而进行汇编。

接下来通过链接器。链接器的作用是将目标代码和目标库之间进行连接缝合。链接器会将代码和数据模块按照符号特征一起放入内存，重写数据和指令标签的地址，最后修正目标文件中的内部引用以及外部引用。从而生成可执行文件。可执行文件和目标文件的格式是相同的，但是目标文件中可能有未解析的引用。

在运行时，需要加载器进行工作。加载器会把可执行文件加载到内存中并启动之。

除去静态链接库，还有一种链接方式是使用动态链接库(DLL)。这是因为静态链接库可能很大，并且在库代码更新后，原程序并不会实时更新，需要重编译等操作。

起初的DLL，是运行一个动态的链接程序，使用额外的信息来查找相应的库并更新外部引用，但是它还是链接了所有可能的例程。DLL的延迟过程链接版本改良了这一点。当需要一个DLL中的程序时，程序会调用一个虚入口。它会加载一个表示目标例程的编号，然后到达动态链接器或者加载器。由其找到所需例程，并且修改虚入口之后的跳转地址。在后续对这个相同例程的调用时，操作系统会使用虚拟内存进行管理，之后不必再执行重映射操作。

曾经，指针自增比数组的效率更高，因为加法比乘法方便。但是现在的编译器可以帮我们做这些内容了。

ARM：最流行的嵌入式设备使用的架构。

ARM是另外一种与RISCV相类，但组成很不同的架构。它具有更多的寻址方式，并且有传统的四位条件码：负，零，进位，溢出。

ARM中的12位立即数：字段低8位零扩展为32位值，然后循环右移。移位次数是字段高四位指定的数字乘2。

循环右移：将最右侧的值右移至首位。

ARM支持保存一组寄存器。称为块加载和块存储等。

x86一直在不断更新。1985年发布了80386.但是通用寄存器只有8个。

x86存在一种很特殊的寻址方式，暂称之为比例下标寻址好了。即$基址+2^{比例}\times 下标，比例\in\{0,1,2,3\}$

x86的整数运算中存在数据传送指令，比如move, push, pop等指令。其亦存在字符串指令，包括字符串传送和字符串比较等。push和pop能够把数据在栈中进行读取。x86中甚至存在loop这种循环指令，也存在inc,dec等自增，自减指令。

RISCV中基本结构的剩余指令:slt, sltu, slti, sltiu, auipc.

auipc很合适于在动态链接库中使用。

Python 的解释器性质决定了性能不会比C 的编译器好。

## 算术运算

### 加减法

在计算机中，减法显然可以通过加法进行计算。实现加法和减法的硬件是ALU.

有的加法器存在**饱和**，即超出最大上限时，为最大值；低于最低下限时，为最小值。

#### 超前进位

关键无论输入何时改变，硬件总会并行执行。考虑$a+b$，则：

$$
c_{i+1}=(b_i\cdot c_i) +(a_i\cdot c_i) +(a_i\cdot b_1)
$$

这无非是在描述只要有两个是1，就得进位。上式也可以写成：

$$
c_{i+1}=(a_i+b_i)\cdot c_i+(a_i\cdot b_i)
$$

我们定义：

$$
g_i=a_i\cdot b_i\\
p_i=a_i+b_i
$$

从而，上式可以写成：

$$
c_{i+1}=g_i+p_i\cdot c_i
$$

g表示generate，p表示propagate.也就是说，只要$g_i=1$,那么一定会产生进位。如果$p_i=1$，那么一定可以把上一位的进位传递下去。

然后，我们可以把几个带有超前加法的位加法器捆在一起。把多组这样的捆绑捆在一起，可以得到一个更大的超前进位加法器。

### 乘法

最平凡的方式：被乘数用双倍空间存，乘数用正常空间存。每次周期乘法结束后，被乘数左移一位，乘数右移一位。每次仅考察乘数的最后一位。这样，只需要把被乘数和积之间作运算就可以了。

为了对硬件进行优化，我们可以充分利用双倍空间的积寄存器。我们可以把乘数储存在积寄存器中，每次同样只操作乘数的最后一位，结果加在积寄存器的高位上。每次对积寄存器进行右移。

带符号乘法是平凡的。我们只需要把符号先记录下来就好了。

还有一种方式，是我们可以考虑使用一堆加法器，组成一棵树的形状来加速这个过程。

### 除法

最简单的除法，那就是移位加减法。一开始把余数寄存器初始化为被除数。这很符合人类直觉，不复赘述。

改进版本是类似的。只不过能够优化下硬件罢了。就是把余数寄存器和商寄存器存储在了一起。

有符号的除法是类似的。

快速除法一般采用查表法来预测。通过余数后六位和除数前四位预测这一点。

### 浮点数运算

浮点数运算采取的是科学计数法。整数部分为1.形如：

$$
1.xxxxx...\times 2^{yyyy...}
$$

32位浮点数一位符号，8位指数，23位尾数。浮点数的特点是会产生上溢和下溢。对于64位浮点数，指数为11位，尾数为52位。

有的时候，发生上溢出或者下溢出会产生中断。



### IEEE 754的浮点数标准

如果一个浮点数的指数为0，但是尾数不是0，那么其表示的对象是正负非规格化的浮点数。如果指数位全为1，尾数位为0，那么我们用它表示正负无穷。如果指数位全为1，尾数不为0那么我们用它来表示非数(NaN)。



### 浮点数加法

把浮点数指数较小的数字的指数转化为和指数较大的浮点数相同。即将尾数进行右移。然后，将二者进行有效位数相加。然后，进行规格化。



### 浮点数乘法

平凡地，正如直觉那样，先把两个数字的指数相加。然后，将两个数字的尾数部分进行相乘，得到计算的结果，然后得到规格化的表示。



### 浮点数运算中的精确算术

在运算的过程中，会额外保留两个bit，这样在舍入的时候会更加精确。

### 一些常见问题

- 右移不等价于除以2的整数次幂。

- 浮点数加法不满足结合律。因为溢出！
