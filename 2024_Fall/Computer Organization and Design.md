# 计算机组成与设计

## 第一章 计算机抽象及相关技术

存储容量的十进制术语和二进制术语的区别：KB, MB, GB 为十进制；KiB, MiB, GiB 为二进制。

计算机体系结构的七个“伟大思想”：

- 使用抽象(abstraction)简化设计

- 加速大概率事件

- 并行提高性能

- 流水线提高性能

- 预测提高性能

- 存储分层

- 冗余提高可靠性

计算机的经典部件：输入设备，输出设备，存储器，数据通路（运算器），控制器。后二部分合称处理器。

RAM名字的由来：访问RAM中各部分的数据，时间基本一致。内存即为DRAM，D表示dynamic；cache则为SRAM,即static.

存储器分为易失性存储器和非易失性存储器。前者称为主存储器或一级存储器。后者称为二级存储器。

Amdahl定律：$t = \frac{a}{k} + a'$，a为被加速部分，k为加速比，$a'$为未加速部分。说明性能优化与整体的关系。

SRAM,DRAM,二级存储器构成了存储器层次(hierarchy of memory)中的三层。

在个人移动设备中，二级存储器常是闪存而非磁盘。

闪存体积小，可靠性好，能耗低，但是一个单元写入1e5至1e6次就可能损坏。

CPI：CPU时间周期数除以指令数。

## 第二章 指令

指令系统(instruction set):指令的词汇表。

JAVA一开始是解释器。如今为了性能，会进行即时编译从而运行。

指令的设计原则1：简单源于规整。要好翻译。

算术运算指令

在RISC-V中，32位称为字，64位称为双字(doubleword)。

指令的设计原则2：更少则更快。指令的操作数如果过多，那么很有可能会增加时钟周期。因为电信号传播耗时增加了。

数据传输指令

计算机分为大端编址和小端编址。大端编址：存储内容的高位存储在高字节中。小端编址则相反。

寄存器比内存显然快得多。并且，内存数据必须先读出。因此寄存器明显有着更高的吞吐率。

立即数操作也可以减少存取指令。RSIC-V有着常零寄存器，方便我们进行操作。

二进制补码(two's complement)

这种存储方式利用的是算术上的溢出。考虑到这一点，我们可以将有符号数用统一的公式表示。即：

$$
x=(x_{31}\times (-2)^{31})+\sum_{i=0}^{30}(x_i\times 2^i)
$$

符号扩展的过程就是在数据左侧填充符号位，正确地表达目标数。有符号载入也是这个过程。

为什么不使用反码？因为计算过程中需要额外的一步去计算。虽然正数和负数是平衡的，但却存在正零和负零。

计算机中的指令表示：二进制机器码。称这种指令的设计为指令格式。在RSIC-V中，指令都为32位长。符合简单源于规整的原则。我们把RISCV指令的每一部分称为一个字段。

一般的RISCV指令组成是：funct(7)+rs2(5)+rs1(5)+funct(3)+rd(5)+opcode(7)

所加的每一项都是指令的一个字段。

设计原则3：优秀的设计需要适当的折中。

上所述为R型指令。考虑到某些指令需要更长的字段，从而有:

- I型：immediate(12)+rs1(5)+funct(3)+rd(5)+opcode(7)

- S型：immediate(11:5)+rs2(5)+rs1(5)+funct(3)+immediate(4:0)+opcode(7)

为什么S型这么奇怪？这是为了保证rs1和rs2在不同指令中处于相同位置，降低硬件设计的复杂性。其他字段亦是同理。

考虑到指令长度与寄存器数量有不可分割的关系，所以大部分架构寄存器数量为16或32个。

逻辑操作

在RSICV中没有取反操作。因为取反等价于和-1取异或。

c++中位字段的使用：

```cpp
//ref:https://blog.csdn.net/wendyWJGU/article/details/134880176

#include <iostream>
using namespace std;

#include <fstream>
struct Data1
{
    unsigned int bit0 : 1;
    unsigned int bit1 : 3;
    unsigned int bit2 : 6;
    unsigned int bit3 : 22;
};

int main()
{  
    unsigned int uSrcData = 0x12345678;

    cout << hex << "\n\nuSrcData = 0x" << uSrcData << endl;
    Data1 d2;
    d2.bit0 = uSrcData >> 31;
    d2.bit1 = (uSrcData >> 28);
    d2.bit2 = (uSrcData >> 22);
    d2.bit3 = (uSrcData);

    cout << hex << "bit0 = 0x" << d2.bit0 << endl;//0x0
    cout << hex << "bit1 = 0x" << d2.bit1 << endl;//0x1
    cout << hex << "bit2 = 0x" << d2.bit2 << endl;//0x8
    cout << hex << "bit3 = 0x" << d2.bit3 << endl;//0x345678
}
```

对位字段进行合适的操作，可以方便地取出无符号数中我们想要的内容。

分支地址表：在数据区存储多分支的起始地址。当遇到多分支结构时，在这部分进行寻址。这样可以减少分支语句数。

计算机硬件对过程的支持：比如ra(x1),a0-a7(x10-x17)这些寄存器。

栈指针sp(x2)

x5-x7及x28-x31为t0-t6

x8-x9及x18-x27为s0-s11

如果一个过程不调用其他的过程，那么我们称这个过程为叶子过程。如果在嵌套过程中，那么我们就需要将必要保存的寄存器进行压栈，调整sp.

x3(gp)的作用：为了简化对静态数据的访问，**部分**RSICV保留x3用作全局指针。

栈也会为局部变量分配空间。我们把保存有寄存器和存储有局部变量的段称为过程帧或者活动记录。有些编译器使用fp(x8)用作帧指针。指向帧的第一个字。如果对sp处理得好也许可以不用这一点。

栈从用户地址空间的高端开始。低端内存的第一部分为保留区。第二部分为代码区。第三部分为静态数据区。第四部分为堆区。也就是说，栈和堆是**相向**生长的，这样有利于对内存的高效利用。C调用malloc和free来分配空间或者释放空间。

RSICV中，栈空间从0x0000 0x3f ffff fff0开始向下；代码从0x0000 0000 0040 0000 开始向上。静态数据区从文本段末开始。

尾调用具有高效的迭代。

ASCII码对人类非常友好。但是java中，为了更有包容性，其默认采用unicode编码。其默认采用16位表示一个字符。riscv保持16字节栈空间对齐。

RSICV中的寻址模式，无非是立即数寻址，寄存器寻址，基址寻址（寄存器加常量）和PC相对寻址四种。条件分支只能到达附近的区域。

### 并行

如果并行执行的任务之间不相互同步，就存在数据竞争的风险。并行机制依赖于硬件提供的同步指令。

在互斥区中的数据，只有单个处理器可以操作。

RSICV中对并行的支持指令：lr.w（保留加载）和sc.w（条件存储）等。这两条指令要顺序使用。也就是先进行保留加载，再进行条件存储。如果保留加载的目标地址，在条件存储执行之前，其中内容发生了变化，那么就不会成功。sc.w有三个寄存器参数。第一个rd用于表征存储成功还是失败，值为1或0。rs1指定存储的内容，rs2指定地址。利用这两个指令，可以实现原子交换。这样的操作可以构建更多的原子操作。要想获得锁变量，我们也需要进行原子的操作。但是，释放的时候就随意了。

### 翻译

首先通过编译器。编译器的作用，就是把高级语言转换为汇编语言。

然后通过汇编器。汇编器的作用是对伪指令进行转换。转换为RISCV中的基本指令,并且生成二进制机器码，生成目标文件。在汇编器中，对符号表和指令位置进行了很好的维护，从而进行汇编。

接下来通过链接器。链接器的作用是将目标代码和目标库之间进行连接缝合。链接器会将代码和数据模块按照符号特征一起放入内存，重写数据和指令标签的地址，最后修正目标文件中的内部引用以及外部引用。从而生成可执行文件。可执行文件和目标文件的格式是相同的，但是目标文件中可能有未解析的引用。

在运行时，需要加载器进行工作。加载器会把可执行文件加载到内存中并启动之。

除去静态链接库，还有一种链接方式是使用动态链接库(DLL)。这是因为静态链接库可能很大，并且在库代码更新后，原程序并不会实时更新，需要重编译等操作。

起初的DLL，是运行一个动态的链接程序，使用额外的信息来查找相应的库并更新外部引用，但是它还是链接了所有可能的例程。DLL的延迟过程链接版本改良了这一点。当需要一个DLL中的程序时，程序会调用一个虚入口。它会加载一个表示目标例程的编号，然后到达动态链接器或者加载器。由其找到所需例程，并且修改虚入口之后的跳转地址。在后续对这个相同例程的调用时，操作系统会使用虚拟内存进行管理，之后不必再执行重映射操作。

曾经，指针自增比数组的效率更高，因为加法比乘法方便。但是现在的编译器可以帮我们做这些内容了。

ARM：最流行的嵌入式设备使用的架构。

ARM是另外一种与RISCV相类，但组成很不同的架构。它具有更多的寻址方式，并且有传统的四位条件码：负，零，进位，溢出。

ARM中的12位立即数：字段低8位零扩展为32位值，然后循环右移。移位次数是字段高四位指定的数字乘2。

循环右移：将最右侧的值右移至首位。

ARM支持保存一组寄存器。称为块加载和块存储等。

x86一直在不断更新。1985年发布了80386.但是通用寄存器只有8个。

x86存在一种很特殊的寻址方式，暂称之为比例下标寻址好了。即$基址+2^{比例}\times 下标，比例\in\{0,1,2,3\}$

x86的整数运算中存在数据传送指令，比如move, push, pop等指令。其亦存在字符串指令，包括字符串传送和字符串比较等。push和pop能够把数据在栈中进行读取。x86中甚至存在loop这种循环指令，也存在inc,dec等自增，自减指令。

RISCV中基本结构的剩余指令:slt, sltu, slti, sltiu, auipc.

auipc很合适于在动态链接库中使用。

Python 的解释器性质决定了性能不会比C 的编译器好。

## 算术运算

### 加减法

在计算机中，减法显然可以通过加法进行计算。实现加法和减法的硬件是ALU.

有的加法器存在**饱和**，即超出最大上限时，为最大值；低于最低下限时，为最小值。

#### 超前进位

关键无论输入何时改变，硬件总会并行执行。考虑$a+b$，则：

$$
c_{i+1}=(b_i\cdot c_i) +(a_i\cdot c_i) +(a_i\cdot b_1)
$$

这无非是在描述只要有两个是1，就得进位。上式也可以写成：

$$
c_{i+1}=(a_i+b_i)\cdot c_i+(a_i\cdot b_i)
$$

我们定义：

$$
g_i=a_i\cdot b_i\\
p_i=a_i+b_i
$$

从而，上式可以写成：

$$
c_{i+1}=g_i+p_i\cdot c_i
$$

g表示generate，p表示propagate.也就是说，只要$g_i=1$,那么一定会产生进位。如果$p_i=1$，那么一定可以把上一位的进位传递下去。

然后，我们可以把几个带有超前加法的位加法器捆在一起。把多组这样的捆绑捆在一起，可以得到一个更大的超前进位加法器。

### 乘法

最平凡的方式：被乘数用双倍空间存，乘数用正常空间存。每次周期乘法结束后，被乘数左移一位，乘数右移一位。每次仅考察乘数的最后一位。这样，只需要把被乘数和积之间作运算就可以了。

为了对硬件进行优化，我们可以充分利用双倍空间的积寄存器。我们可以把乘数储存在积寄存器中，每次同样只操作乘数的最后一位，结果加在积寄存器的高位上。每次对积寄存器进行右移。

带符号乘法是平凡的。我们只需要把符号先记录下来就好了。

还有一种方式，是我们可以考虑使用一堆加法器，组成一棵树的形状来加速这个过程。

### 除法

最简单的除法，那就是移位加减法。一开始把余数寄存器初始化为被除数。这很符合人类直觉，不复赘述。

改进版本是类似的。只不过能够优化下硬件罢了。就是把余数寄存器和商寄存器存储在了一起。

有符号的除法是类似的。

快速除法一般采用查表法来预测。通过余数后六位和除数前四位预测这一点。

### 浮点数运算

浮点数运算采取的是科学计数法。整数部分为1.形如：

$$
1.xxxxx...\times 2^{yyyy...}
$$

32位浮点数一位符号，8位指数，23位尾数。浮点数的特点是会产生上溢和下溢。对于64位浮点数，指数为11位，尾数为52位。

有的时候，发生上溢出或者下溢出会产生中断。

### IEEE 754的浮点数标准

如果一个浮点数的指数为0，但是尾数不是0，那么其表示的对象是正负非规格化的浮点数。如果指数位全为1，尾数位为0，那么我们用它表示正负无穷。如果指数位全为1，尾数不为0那么我们用它来表示非数(NaN)。

### 浮点数加法

把浮点数指数较小的数字的指数转化为和指数较大的浮点数相同。即将尾数进行右移。然后，将二者进行有效位数相加。然后，进行规格化。

### 浮点数乘法

平凡地，正如直觉那样，先把两个数字的指数相加。然后，将两个数字的尾数部分进行相乘，得到计算的结果，然后得到规格化的表示。

### 浮点数运算中的精确算术

在运算的过程中，会额外保留两个bit，这样在舍入的时候会更加精确。

### 子字并行

一个128位的加法器，也可以视作16个8位加法器。这种对短向量分割后，进行并行处理的方式可以提高处理的速度。  

### 一些常见问题

- 右移不等价于除以2的整数次幂。

- 浮点数加法不满足结合律。因为溢出！

## 处理器

### 时钟同步方法

采用沿边触发的时钟。这样，可以保证每个部件对状态的读取和修改具有同时性。

如果一个部件，并不是每一个时钟周期都会做出反应，那么我们需要额外采取一个控制信号，来控制信号的更新。我们用有效(asserted)来表示控制信号的高电平。反之，则表示低电平。

### 数据通路

数据通路单元：用于操作或者保存处理器中数据的单元。RISCV中，包括指令存储器、数据存储器、寄存器堆、ALU、加法器。

一般而言，寄存器堆需要有两个读端口（因为有不少指令一次要读两个寄存器中的内容）和一个写端口。这几个端口的导线都是5位的。此外，还有三根对应的数据线。它们都是32位的，用于传输数据。同时，寄存器堆需要有一个写控制信号。从而保证只在我们需要的上升（下降）沿进行写操作。

立即数生成单元，可以把指令中的一些立即数进行符号扩展，然后用于使用。这在存取指令中很常见。

在数据存储单元中，我们有一个地址输入，写数据输入和读数据输出。该单元，不可以同时执行两种指令。并且，它既需要一个读信号，也需要一个写信号。

分支指令判断：从寄存器堆中读取内容。判断分支是否成立。然后，选择对PC的操作方式。

可以通过多路选择器，将一些较为相近的结构进行复用。

小型的ALU控制单元：将机器码翻译成需要ALU进行的操作的译码。

主控制单元：首先，由于RISCV中的机器码具有一定的规律性，所以在处理时，数据通路得到了一定的简化。从而对硬件进行简化，甚至一定程度上加快了运行的速度。

指令格式固定的好处在于，可以直接把对应位置的编码强加到目标位置上，而无需考虑opcode。opcode起到的是控制线的作用。也就是说，将opcode加到主控单元中，然后由主控单元决定对每一个单元的控制。

### 数据通路的操作

#### R型指令的数据通路操作

1. 取出指令，PC自增。

2. 从寄存器中读出内容，主控制单元计算控制信号。

3. 根据操作码确定ALU功能，对读出的数据进行操作。

4. 将ALU结果写入目标的寄存器。

### 流水线

流水线不能提高单步骤的速度。但是，流水线可以提高系统的吞吐率，从而减少完成整个任务的时间。

RISCV指令执行通常包含五个步骤：取指令、读寄存器并译码、执行操作或者计算地址、访问数据存储器中的操作数、将结果写入寄存器。

现代x86架构中，x86指令的长度不同，为了方便进行处理，所以会将这样的指令转化为像RSICV中那样的简单指令进行处理。

### 流水线冒险

#### 结构冒险

硬件上的不支持。但由于RSICV是面向流水线设计的，所以这一点较为容易避免。

#### 数据冒险

一个步骤必须等待另一个步骤完成的情况。为了解决这个问题，我们采用称为前递(forwarding)或者旁路(bypassing)的方式来优化这一点。也就是说，在数据还没有被显式地写入寄存器中时，就将其传给目标指令。

对如load等指令而言，会造成流水线上更长时间的停顿，也就是为了处理载入-使用型数据冒险导致的情况。

#### 控制冒险

需要根据指令的结果做出决定。但是决定是否跳转的指令正在运行中。因此，我们一般采用预测的方式来处理条件分支。因为停顿这种解决方式太慢了。还有一种方式来解决这个问题，我们称之为延迟决定(delayed decision)。也就是说，我们把一些与分支无关的指令，放到计算跳转条件值之后进行。

### 流水线数据通路和控制

#### 指令的五个阶段

1. IF:取指令

2. ID:指令译码和读寄存器堆

3. EX:执行或计算地址

4. MEM:存储器访问

5. WB:写回

上述的五个过程是一次执行的。但是，存在两种反向的数据流动，可能会对后续指令的执行产生影响。它们是：

- 写回过程中，会对寄存器堆产生影响。

- 下一PC值会根据运算结果进行选择。

利用上升沿和下降沿，保持正确的时序。

可以前半周期写入，后半周期读入。

也就是说，我们可以把每一部分进行分离，后半周期读入，前半周期写入。每一个逻辑部件之间实现分离。

#### 流水线控制

类似之前的方式。利用不同的opcode，对不同的逻辑部件进行控制。比如说，我们考虑是否对内存进行读取，ALU将要执行的指令到底是个R指令还是个I指令，PC应当要变为何值等问题。这里我们可以使用一个MUX来解决这个问题。在这里，我们可以使用一个MUX来决定最终读取的内容。

### 前递与停顿

冒险的两对条件：

- 运算结果储存对象为运算数之一。

- 访存结果储存对象为运算数之一。

为了解决这些问题，我们可以使用前递单元来解决这个问题。也就是说，将运算所得结果通过前递单元递回，通过MUX决定最终采取哪一个数值。在前递单元中，我们可以选择三种状态：由寄存器堆取的内容；由ALU运算结果取得内容，由访存取得的内容。

#### 数据冒险与停顿

一种常见的解决方法，是通过插入一条空指令来解决这个问题。



#### 三种常见的数据依赖

- 写后读（WAR）

- 写后写（WAW）

- 读后写（RAW）

WAR是真实的数据依赖。剩下两个则是虚假的数据依赖。对于后两者，我们可以使用寄存器重命名的方式来解决。
