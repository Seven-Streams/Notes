# 操作系统

## Lec 1

### 为什么学操作系统？

学任何东西的原因：**重走从无到有的发现历程** by JYY

概念的产生的动机，基本方法，弯路...

应用、创新、革命

操作系统的动机：更快更好地服务更多应用

操作系统的基本方法： "Building Abstractions"

### 学习操作系统能得到什么？

- 了解一些原理，比如窗口如何创建、 Ctrl+C 为什么有的时候不能退出程序等等。

- 能够实现平常用的一些东西。

### 什么是操作系统

操作系统是**管理软/硬件资源、为程序提供服务**的程序。

计算机硬件：

- 极简的公理系统（时钟，导线，逻辑门等等）

- 可以支持非常复杂的电路设计

在本课程中，可以认为操作系统是硬件和软件的中间层。

计算机硬件的发展需求操作系统

1950-1960: 磁芯内存

1950s - 1960s 的操作系统：库函数和管理程序排队运行的调度代码。操作系统的概念大概从这里形成。因为这个时候计算机还很贵，需要人工给小卡片来输入...

1960s - 1970s 的操作系统：能载入多个程序到内存并且调度它们的管理程序。防止程序之间互相干扰。

本节课的主要概念在 70 年代就形成了。

## Lec 2 应用视角的操作系统

- 什么是程序？

- 如何在操作系统上构造程序？

- 编译器的原理是什么？

处理器是状态机

problem: 程序为什么可以停下来？计算机为什么可以关机？

给操作系统发送 syscall

所有的程序也都是状态机

操作系统上的应用程序

提问

`strace` 用于追踪程序的进行

操作系统的职责就是管理和提供舒适的 API

C 语言也是一种状态机

递归和非递归

Problem: 怎么用状态表示递归函数？

那么，我们到底该如何定义状态？

状态：栈帧（含 PC ）+全局变量

函数调用：放入一个栈帧

函数返回：弹出一个栈帧

编译器优化

不改变语义：系统调用的操作完全相同

外部调用是不可优化的

systemcall 真的不可优化？

## Lec 3 硬件视角的操作系统

CPU reset

Firmware:配置计算机系统

Firmware 的作用：

- 进行计算机系统配置，比如 CPU 电压，接口的开关等等...

- 加载操作系统

早期时，是 BIOS(Basic I/O System)

Firmware 通常都是只读的

UEFI

在 40 年前， Firmware 会读取前 512 Byte 到 0x7c00, 只要这 512 Byte 最后是 0x55 和 0xAA

再扣除掉 64 Byte 的分区表，共有 446 字节可以供程序员进行修改。

## Lec 4 数学视角的操作系统

“严格性”

程序是一种数学严格的对象

 Everything is a state machine!

严格性给我们带来的 insights

- 写一些 `assert` 

- 容易阅读

- 容易验证

用数学方法理解操作系统？

操作系统就是状态机的管理者

- 进程

- 系统调用

- 上下文切换

- 调度

计算机系统中的不确定性

- 调度：选择哪个状态机？

- I/O: 系统外的输入不确定

状态图

## Lec 5 多处理器编程

### 多线程编程模型

独立的“栈帧”和共享的“内存”。

状态迁移：挑选一个线程走一步。

简易化的模型：

- `spawn(fn)`：用于创建一个入口函数是 `fn` 的线程，并且开始执行。行为是 `sys_spawn(fn, tid)`

- `join()`: `while(done != T) sys_sched()` 用于等待所有运行线程的返回。

OS 会自动把线程放在不同的处理器上。从而 CPU 使用率可以超过 100%

线程具有独立的栈区。栈区大小有上限，但是我们可以调整。

### 并发编程的放弃点：状态迁移原子性的假设

共享内存使得原子性假设不再成立。

几乎所有尝试在共享内存上实现原子性的实现都是错的。直到 Dekker's Algorithm, 其可以保证两个线程的互斥。

### 并发编程的放弃点：程序顺序执行的假设

编译器可能也会进行一定的优化

### 并发编程的放弃点：全局指令顺序的假设

处理器也可以看做是一种编译器

不同处理器可能看到不同的共享内存

## Lec 6 并发控制：互斥(1)

并发编程困难的原因：推翻了顺序执行的基本假设

### 互斥

这样可以把指定的多次状态迁移转化为一次大的状态迁移，再次回到人类擅长的领域。

Gustafson's law: $T_p < T_{\infin}+\frac{T_1}{p}$

计算上，我们可以进行并行。因为经典物理中也是有局部性原理的！

如何实现互斥？

### 关中断

在一段时间上禁止中断，就实现了互斥的效果

处理器也有一些不可屏蔽中断(Non-Maskable Interrupts, NMI) ，比如电源坏了等等。

普通的应用程序不具有关中断的权利。

中断是在每个处理器上独享的。因此需要更多的方式。

### Peterson's Algorithm

实现假设：

- 任何时候都可以执行一条 load/store 指令

- 读写本身是原子的

若想进入临界区，则：

1. store 本线程的 flag

2. store 临界区的权限设定为对方线程所有

然后，进入观察模式：

1. load 对方线程 flag 

2. load 临界区权限是谁

如果对方线程  flag 为 0, 或者临界区权限是自己，那么进入临界区。

出临界区时，则：store 本线程 flag 为 0.

Tree of Thoughts

但是在现在多处理器的内存模型中，实际的 Peterson 算法就不再正确了！

在现在想要实现，那么就需要加上 barrier

并且，这个模型针对的是两个线程。

### 多处理器上的互斥实现

“闭着眼睛贴”和“睁着眼睛看”

软件不够，硬件来凑！

**原子指令**

**自旋锁**

原子交换

如果持锁线程发生中断，自旋锁又会发生什么？

## Lec 7 并发控制：互斥(2)

- safety: 在处理器上正确。并且如果一个线程持有锁，其他线程不可返回。
- liveness: 多个线程执行 `lock` 时，至少有一个可以返回。

### 操作系统内核的自旋锁

问题在于，任何一个 CPU 都可以发生中断。如果在持锁期发生中断，可能就死锁了。

实现的方式：关中断+自旋锁

在关中断过程中不可以随意打开中断，也不能随意关闭中断。因此，需要额外去保存中断状态。

Problem: 在哪里保存中断状态？

### Read-Copy-Update

自旋锁的问题：并发量过大时，性能下降严重。

许多对象具有 read-mostly 的特点。

每次在更新的时候，创建一个新的变量。在访问时，通过一个指针来访问。当修改完成后，把指针修改为指向新变量。

当所有的 CPU 进行一次线程的切换后，那么就可以把旧变量回收掉了。

### 应用程序与互斥锁

自旋的后果：

- 自选会导致空转

- 应用程序不可以关中断

解决的方式：既然只能空转，不然切换到其他线程做别的事情。 `syscall`

#### futex: fast userspace mutexes

- fash path:自旋成功，那么进入临界区。

- slow path:自旋失败，给系统发出信号，假装自旋一下。 

## Lec 8 调试理论

有时我们的代码正确了，但是编译器可能帮我们优化错了！

有的时候需要添加 **compiler barrier**

并发 bug 的触发也需要运气，有的时候甚至还需要特定的硬件（

初学者最好用保证正确的实现()

### bug 和 debug

1. 机器永远是对的

2. 未测代码永远是错的

需求 $\to$ 设计 $\to$ 代码(Fault/bug) $\to$ 执行(Error) $\to$ 失败(Failure)

如果我们能判断任意状态的正确性，那么给定一个 failure, 我们可以二分查到第一个 error,这里就是 fault 的产生。

但问题我们怎么判断？？

调试的过程，就是观察状态机执行的某个方面。

两种基本工具： print 和 gdb

一切都可以调试！

操作系统怎么“看到”内部的问题？

`strace` ： 追踪系统调用

`perf`：状态机采样

大部分工具也存在日志可以查询！

 gdb cheat sheet

- 还是要写好的代码：需求和设计；不言自明；不言自证。

- 并且应该要做好测试工作

- 多写 assert

 
