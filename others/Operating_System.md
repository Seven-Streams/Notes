# 操作系统

## Lec 1

### 为什么学操作系统？

学任何东西的原因：**重走从无到有的发现历程** by JYY

概念的产生的动机，基本方法，弯路...

应用、创新、革命

操作系统的动机：更快更好地服务更多应用

操作系统的基本方法： "Building Abstractions"

### 学习操作系统能得到什么？

- 了解一些原理，比如窗口如何创建、 Ctrl+C 为什么有的时候不能退出程序等等。

- 能够实现平常用的一些东西。

### 什么是操作系统

操作系统是**管理软/硬件资源、为程序提供服务**的程序。

计算机硬件：

- 极简的公理系统（时钟，导线，逻辑门等等）

- 可以支持非常复杂的电路设计

在本课程中，可以认为操作系统是硬件和软件的中间层。

计算机硬件的发展需求操作系统

1950-1960: 磁芯内存

1950s - 1960s 的操作系统：库函数和管理程序排队运行的调度代码。操作系统的概念大概从这里形成。因为这个时候计算机还很贵，需要人工给小卡片来输入...

1960s - 1970s 的操作系统：能载入多个程序到内存并且调度它们的管理程序。防止程序之间互相干扰。

本节课的主要概念在 70 年代就形成了。

## Lec 2 应用视角的操作系统

- 什么是程序？

- 如何在操作系统上构造程序？

- 编译器的原理是什么？

处理器是状态机

problem: 程序为什么可以停下来？计算机为什么可以关机？

给操作系统发送 syscall

所有的程序也都是状态机

操作系统上的应用程序

提问

`strace` 用于追踪程序的进行

操作系统的职责就是管理和提供舒适的 API

C 语言也是一种状态机

递归和非递归

Problem: 怎么用状态表示递归函数？

那么，我们到底该如何定义状态？

状态：栈帧（含 PC ）+全局变量

函数调用：放入一个栈帧

函数返回：弹出一个栈帧

编译器优化

不改变语义：系统调用的操作完全相同

外部调用是不可优化的

systemcall 真的不可优化？

## Lec 3 硬件视角的操作系统

CPU reset

Firmware:配置计算机系统

Firmware 的作用：

- 进行计算机系统配置，比如 CPU 电压，接口的开关等等...

- 加载操作系统

早期时，是 BIOS(Basic I/O System)

Firmware 通常都是只读的

UEFI

在 40 年前， Firmware 会读取前 512 Byte 到 0x7c00, 只要这 512 Byte 最后是 0x55 和 0xAA

再扣除掉 64 Byte 的分区表，共有 446 字节可以供程序员进行修改。

## Lec 4 数学视角的操作系统

“严格性”

程序是一种数学严格的对象

 Everything is a state machine!

严格性给我们带来的 insights

- 写一些 `assert` 

- 容易阅读

- 容易验证

用数学方法理解操作系统？

操作系统就是状态机的管理者

- 进程

- 系统调用

- 上下文切换

- 调度

计算机系统中的不确定性

- 调度：选择哪个状态机？

- I/O: 系统外的输入不确定

状态图

## Lec 5 多处理器编程

### 多线程编程模型

独立的“栈帧”和共享的“内存”。

状态迁移：挑选一个线程走一步。

简易化的模型：

- `spawn(fn)`：用于创建一个入口函数是 `fn` 的线程，并且开始执行。行为是 `sys_spawn(fn, tid)`

- `join()`: `while(done != T) sys_sched()` 用于等待所有运行线程的返回。

OS 会自动把线程放在不同的处理器上。从而 CPU 使用率可以超过 100%

线程具有独立的栈区。栈区大小有上限，但是我们可以调整。

### 并发编程的放弃点：状态迁移原子性的假设

共享内存使得原子性假设不再成立。

几乎所有尝试在共享内存上实现原子性的实现都是错的。直到 Dekker's Algorithm, 其可以保证两个线程的互斥。

### 并发编程的放弃点：程序顺序执行的假设

编译器可能也会进行一定的优化

### 并发编程的放弃点：全局指令顺序的假设

处理器也可以看做是一种编译器

不同处理器可能看到不同的共享内存

## Lec 6 并发控制：互斥(1)

并发编程困难的原因：推翻了顺序执行的基本假设

### 互斥

这样可以把指定的多次状态迁移转化为一次大的状态迁移，再次回到人类擅长的领域。

Gustafson's law: $T_p < T_{\infin}+\frac{T_1}{p}$

计算上，我们可以进行并行。因为经典物理中也是有局部性原理的！

如何实现互斥？

### 关中断

在一段时间上禁止中断，就实现了互斥的效果

处理器也有一些不可屏蔽中断(Non-Maskable Interrupts, NMI) ，比如电源坏了等等。

普通的应用程序不具有关中断的权利。

中断是在每个处理器上独享的。因此需要更多的方式。

### Peterson's Algorithm

实现假设：

- 任何时候都可以执行一条 load/store 指令

- 读写本身是原子的

若想进入临界区，则：

1. store 本线程的 flag

2. store 临界区的权限设定为对方线程所有

然后，进入观察模式：

1. load 对方线程 flag 

2. load 临界区权限是谁

如果对方线程  flag 为 0, 或者临界区权限是自己，那么进入临界区。

出临界区时，则：store 本线程 flag 为 0.

Tree of Thoughts

但是在现在多处理器的内存模型中，实际的 Peterson 算法就不再正确了！

在现在想要实现，那么就需要加上 barrier

并且，这个模型针对的是两个线程。

### 多处理器上的互斥实现

“闭着眼睛贴”和“睁着眼睛看”

软件不够，硬件来凑！

**原子指令**

**自旋锁**

原子交换

如果持锁线程发生中断，自旋锁又会发生什么？

## Lec 7 并发控制：互斥(2)

- safety: 在处理器上正确。并且如果一个线程持有锁，其他线程不可返回。
- liveness: 多个线程执行 `lock` 时，至少有一个可以返回。

### 操作系统内核的自旋锁

问题在于，任何一个 CPU 都可以发生中断。如果在持锁期发生中断，可能就死锁了。

实现的方式：关中断+自旋锁

在关中断过程中不可以随意打开中断，也不能随意关闭中断。因此，需要额外去保存中断状态。

Problem: 在哪里保存中断状态？

### Read-Copy-Update

自旋锁的问题：并发量过大时，性能下降严重。

许多对象具有 read-mostly 的特点。

每次在更新的时候，创建一个新的变量。在访问时，通过一个指针来访问。当修改完成后，把指针修改为指向新变量。

当所有的 CPU 进行一次线程的切换后，那么就可以把旧变量回收掉了。

### 应用程序与互斥锁

自旋的后果：

- 自选会导致空转

- 应用程序不可以关中断

解决的方式：既然只能空转，不然切换到其他线程做别的事情。 `syscall`

#### futex: fast userspace mutexes

- fash path:自旋成功，那么进入临界区。

- slow path:自旋失败，给系统发出信号，假装自旋一下。 

## Lec 8 调试理论

有时我们的代码正确了，但是编译器可能帮我们优化错了！

有的时候需要添加 **compiler barrier**

并发 bug 的触发也需要运气，有的时候甚至还需要特定的硬件（

初学者最好用保证正确的实现()

### bug 和 debug

1. 机器永远是对的

2. 未测代码永远是错的

需求 $\to$ 设计 $\to$ 代码(Fault/bug) $\to$ 执行(Error) $\to$ 失败(Failure)

如果我们能判断任意状态的正确性，那么给定一个 failure, 我们可以二分查到第一个 error,这里就是 fault 的产生。

但问题我们怎么判断？？

调试的过程，就是观察状态机执行的某个方面。

两种基本工具： print 和 gdb

一切都可以调试！

操作系统怎么“看到”内部的问题？

`strace` ： 追踪系统调用

`perf`：状态机采样

大部分工具也存在日志可以查询！

 gdb cheat sheet

- 还是要写好的代码：需求和设计；不言自明；不言自证。

- 并且应该要做好测试工作

- 多写 assert

## Lec 9 并发控制：同步(1)

同步的作用：使得多个随时间变化的量在变化过程中保持一定的关系。

即系统到达某个互相已知的状态。

第一种方式：自旋等待同步条件成立。

### 生产者-消费者问题

- Prodecer(生产数据)：如果缓存区有空位，就放入；否则等待。

- Consumer(消费数据)：如果缓冲区有数据，取走；否则等待。

当条件成立时，不可以放弃互斥锁，直接进行操作。实际上，也就是进行了    double check.

使用自旋是很通用简单的方式，但效率很难说。

**条件变量**

`cond_wait(&cv, &lk)`: 目前在等待条件变量 `cv` ，如果不成立，就放弃锁 `lk`. 线程进入睡眠状态。

```cpp
mutex_lock(&mutex);
while(!cond) {
    wait(&cv, &mutex);
}
assert(cond);
...
cv_broad(&cv);
mutex_unlock(&mutex);
```

### 并行编程

只要计算任务可以构成一个有向无环图，并且我们有一个调度者分配任务的效率足够高，算法就可以并行计算。

## Lec 10 并发控制：同步(2)

### 信号量

用互斥锁来实现？每创造一个锁，就获得它。

acquire-release

信号量： mutex + happens-before + 允许多个持有。

```cpp
void Acquire(sem_t *sem) {
    atomic {
        wait_until(sem->count > 0) {
            sem->count--;
        }
    }
}
void Release(sem_t *sem) {
    atomic {
        sem->count++;
    }
}
```

比如： `join()`

信号量的好处在于不用 `notify_all()` ，但问题在于有的时候难以实现。

### 三种手段的对比

信号量： mutex 的自然推广，比较干净。

条件变量：万能，但是不干净。 

条件变量是神（

lock ordering

可以用信号量实现条件变量。

## Lec 11 真实世界的并发编程

web 1.0: 静态刷新

web 2.0: 允许后台刷新

web 网页如果发出了多个请求，就会有并发问题了。

异步——回调函数

Solution: event-based concuerrency

允许创建计算节点(fetch, timer...), 但是禁止计算节点之间并行，只是以事件为单位进行调度。

callback hell

高性能计算

物理世界的空间局部性

```cpp
#pragma omp parallel num_threads(nthread)
#pragma omp for schedule(static)
```

高性能计算中散热可能更麻烦了（

数据中心中的并发

长期的维护工作和高吞吐的请求

协程：和线程类似。但是它会一直执行，直到 `yield()` 才可以放弃 CPU.

Goroutine: 线程和协程的混合。只要发现有很长延迟的操作，如 `sleep` 等等时，把这些操作异步掉，即进行 `yield()`.

go 中的类管道

SIMD

SIMT

## Lec 12 并发 bugs

### 死锁(deadlock)

#### AA-Deadlock

```cpp
lock(&lk);
...
lock(&lk);
```

 通过一定的 `assert` 可以排查。

#### ABBA-Deadlock

死锁产生的必要条件

- Mutual-exclusion

- Wait-for

- No-preemption

- Circular-chain

最简单的方式是防止 circular-chain 的发生。

Lock ordering: 给锁编号。严格按照大小顺序获得锁。

### 数据竞争(data race)

不同线程访问同一个内存，并且至少有一个是写。

这是 UB.

上错锁 or 没上锁是最可能得原因。

### 原子性和顺序违反

代码中被其他操作插入；事件没有按照预定顺序发生。

## Lec 13 应对并发 bugs

软件危机：

- 无法写出所有规约

- 特性的交互组合是指数增长的

### 死锁的应对

lock ordering

运行时检查死锁，数据竞争等等。

可以为每一个线程取得特定锁和释放特定锁时记录日志，构建图。检查是否有环。

对于连续的同一内存，并且没有 happen before 的保证，那么一定会有竞争。

`-fsanitize=thread`

AddressSanitizer(asan): 非法内存访问

ThreadSanitizer(tsan): 数据竞争

...

### 防御性编程

不进行完整的检查，但是实现简单、有用的检查。如 `assert`

Buffer overrun

canary: 用一些额外的内存检查访存越界。

烫烫烫，屯屯屯，葺葺葺

```cpp

```
