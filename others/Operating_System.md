# 操作系统

## Lec 1

### 为什么学操作系统？

学任何东西的原因：**重走从无到有的发现历程** by JYY

概念的产生的动机，基本方法，弯路...

应用、创新、革命

操作系统的动机：更快更好地服务更多应用

操作系统的基本方法： "Building Abstractions"

### 学习操作系统能得到什么？

- 了解一些原理，比如窗口如何创建、 Ctrl+C 为什么有的时候不能退出程序等等。

- 能够实现平常用的一些东西。

### 什么是操作系统

操作系统是**管理软/硬件资源、为程序提供服务**的程序。

计算机硬件：

- 极简的公理系统（时钟，导线，逻辑门等等）

- 可以支持非常复杂的电路设计

在本课程中，可以认为操作系统是硬件和软件的中间层。

计算机硬件的发展需求操作系统

1950-1960: 磁芯内存

1950s - 1960s 的操作系统：库函数和管理程序排队运行的调度代码。操作系统的概念大概从这里形成。因为这个时候计算机还很贵，需要人工给小卡片来输入...

1960s - 1970s 的操作系统：能载入多个程序到内存并且调度它们的管理程序。防止程序之间互相干扰。

本节课的主要概念在 70 年代就形成了。

## Lec 2 应用视角的操作系统

- 什么是程序？

- 如何在操作系统上构造程序？

- 编译器的原理是什么？

处理器是状态机

problem: 程序为什么可以停下来？计算机为什么可以关机？

给操作系统发送 syscall

所有的程序也都是状态机

操作系统上的应用程序

提问

`strace` 用于追踪程序的进行

操作系统的职责就是管理和提供舒适的 API

C 语言也是一种状态机

递归和非递归

Problem: 怎么用状态表示递归函数？

那么，我们到底该如何定义状态？

状态：栈帧（含 PC ）+全局变量

函数调用：放入一个栈帧

函数返回：弹出一个栈帧

编译器优化

不改变语义：系统调用的操作完全相同

外部调用是不可优化的

systemcall 真的不可优化？

## Lec 3 硬件视角的操作系统

CPU reset

Firmware:配置计算机系统

Firmware 的作用：

- 进行计算机系统配置，比如 CPU 电压，接口的开关等等...

- 加载操作系统

早期时，是 BIOS(Basic I/O System)

Firmware 通常都是只读的

UEFI

在 40 年前， Firmware 会读取前 512 Byte 到 0x7c00, 只要这 512 Byte 最后是 0x55 和 0xAA

再扣除掉 64 Byte 的分区表，共有 446 字节可以供程序员进行修改。

## Lec 4 数学视角的操作系统

“严格性”

程序是一种数学严格的对象

 Everything is a state machine!

严格性给我们带来的 insights

- 写一些 `assert` 

- 容易阅读

- 容易验证

用数学方法理解操作系统？

操作系统就是状态机的管理者

- 进程

- 系统调用

- 上下文切换

- 调度

计算机系统中的不确定性

- 调度：选择哪个状态机？

- I/O: 系统外的输入不确定

状态图

## Lec 5 多处理器编程

### 多线程编程模型

独立的“栈帧”和共享的“内存”。

状态迁移：挑选一个线程走一步。

简易化的模型：

- `spawn(fn)`：用于创建一个入口函数是 `fn` 的线程，并且开始执行。行为是 `sys_spawn(fn, tid)`

- `join()`: `while(done != T) sys_sched()` 用于等待所有运行线程的返回。

OS 会自动把线程放在不同的处理器上。从而 CPU 使用率可以超过 100%

线程具有独立的栈区。栈区大小有上限，但是我们可以调整。

### 并发编程的放弃点：状态迁移原子性的假设

共享内存使得原子性假设不再成立。

几乎所有尝试在共享内存上实现原子性的实现都是错的。直到 Dekker's Algorithm, 其可以保证两个线程的互斥。

### 并发编程的放弃点：程序顺序执行的假设

编译器可能也会进行一定的优化

### 并发编程的放弃点：全局指令顺序的假设

处理器也可以看做是一种编译器

不同处理器可能看到不同的共享内存

## Lec 6 并发控制：互斥(1)

并发编程困难的原因：推翻了顺序执行的基本假设

### 互斥

这样可以把指定的多次状态迁移转化为一次大的状态迁移，再次回到人类擅长的领域。

Gustafson's law: $T_p < T_{\infin}+\frac{T_1}{p}$

计算上，我们可以进行并行。因为经典物理中也是有局部性原理的！

如何实现互斥？

### 关中断

在一段时间上禁止中断，就实现了互斥的效果

处理器也有一些不可屏蔽中断(Non-Maskable Interrupts, NMI) ，比如电源坏了等等。

普通的应用程序不具有关中断的权利。

中断是在每个处理器上独享的。因此需要更多的方式。

### Peterson's Algorithm

实现假设：

- 任何时候都可以执行一条 load/store 指令

- 读写本身是原子的

若想进入临界区，则：

1. store 本线程的 flag

2. store 临界区的权限设定为对方线程所有

然后，进入观察模式：

1. load 对方线程 flag 

2. load 临界区权限是谁

如果对方线程  flag 为 0, 或者临界区权限是自己，那么进入临界区。

出临界区时，则：store 本线程 flag 为 0.

Tree of Thoughts

但是在现在多处理器的内存模型中，实际的 Peterson 算法就不再正确了！

在现在想要实现，那么就需要加上 barrier

并且，这个模型针对的是两个线程。

### 多处理器上的互斥实现

“闭着眼睛贴”和“睁着眼睛看”

软件不够，硬件来凑！

**原子指令**

**自旋锁**

原子交换

如果持锁线程发生中断，自旋锁又会发生什么？

## Lec 7 并发控制：互斥(2)

- safety: 在处理器上正确。并且如果一个线程持有锁，其他线程不可返回。
- liveness: 多个线程执行 `lock` 时，至少有一个可以返回。

### 操作系统内核的自旋锁

问题在于，任何一个 CPU 都可以发生中断。如果在持锁期发生中断，可能就死锁了。

实现的方式：关中断+自旋锁

在关中断过程中不可以随意打开中断，也不能随意关闭中断。因此，需要额外去保存中断状态。

Problem: 在哪里保存中断状态？

### Read-Copy-Update

自旋锁的问题：并发量过大时，性能下降严重。

许多对象具有 read-mostly 的特点。

每次在更新的时候，创建一个新的变量。在访问时，通过一个指针来访问。当修改完成后，把指针修改为指向新变量。

当所有的 CPU 进行一次线程的切换后，那么就可以把旧变量回收掉了。

### 应用程序与互斥锁

自旋的后果：

- 自选会导致空转

- 应用程序不可以关中断

解决的方式：既然只能空转，不然切换到其他线程做别的事情。 `syscall`

#### futex: fast userspace mutexes

- fash path:自旋成功，那么进入临界区。

- slow path:自旋失败，给系统发出信号，假装自旋一下。 

## Lec 8 调试理论

有时我们的代码正确了，但是编译器可能帮我们优化错了！

有的时候需要添加 **compiler barrier**

并发 bug 的触发也需要运气，有的时候甚至还需要特定的硬件（

初学者最好用保证正确的实现()

### bug 和 debug

1. 机器永远是对的

2. 未测代码永远是错的

需求 $\to$ 设计 $\to$ 代码(Fault/bug) $\to$ 执行(Error) $\to$ 失败(Failure)

如果我们能判断任意状态的正确性，那么给定一个 failure, 我们可以二分查到第一个 error,这里就是 fault 的产生。

但问题我们怎么判断？？

调试的过程，就是观察状态机执行的某个方面。

两种基本工具： print 和 gdb

一切都可以调试！

操作系统怎么“看到”内部的问题？

`strace` ： 追踪系统调用

`perf`：状态机采样

大部分工具也存在日志可以查询！

 gdb cheat sheet

- 还是要写好的代码：需求和设计；不言自明；不言自证。

- 并且应该要做好测试工作

- 多写 assert

## Lec 9 并发控制：同步(1)

同步的作用：使得多个随时间变化的量在变化过程中保持一定的关系。

即系统到达某个互相已知的状态。

第一种方式：自旋等待同步条件成立。

### 生产者-消费者问题

- Prodecer(生产数据)：如果缓存区有空位，就放入；否则等待。

- Consumer(消费数据)：如果缓冲区有数据，取走；否则等待。

当条件成立时，不可以放弃互斥锁，直接进行操作。实际上，也就是进行了    double check.

使用自旋是很通用简单的方式，但效率很难说。

**条件变量**

`cond_wait(&cv, &lk)`: 目前在等待条件变量 `cv` ，如果不成立，就放弃锁 `lk`. 线程进入睡眠状态。

```cpp
mutex_lock(&mutex);
while(!cond) {
    wait(&cv, &mutex);
}
assert(cond);
...
cv_broad(&cv);
mutex_unlock(&mutex);
```

### 并行编程

只要计算任务可以构成一个有向无环图，并且我们有一个调度者分配任务的效率足够高，算法就可以并行计算。

## Lec 10 并发控制：同步(2)

### 信号量

用互斥锁来实现？每创造一个锁，就获得它。

acquire-release

信号量： mutex + happens-before + 允许多个持有。

```cpp
void Acquire(sem_t *sem) {
    atomic {
        wait_until(sem->count > 0) {
            sem->count--;
        }
    }
}
void Release(sem_t *sem) {
    atomic {
        sem->count++;
    }
}
```

比如： `join()`

信号量的好处在于不用 `notify_all()` ，但问题在于有的时候难以实现。

### 三种手段的对比

信号量： mutex 的自然推广，比较干净。

条件变量：万能，但是不干净。 

条件变量是神（

lock ordering

可以用信号量实现条件变量。

## Lec 11 真实世界的并发编程

web 1.0: 静态刷新

web 2.0: 允许后台刷新

web 网页如果发出了多个请求，就会有并发问题了。

异步——回调函数

Solution: event-based concuerrency

允许创建计算节点(fetch, timer...), 但是禁止计算节点之间并行，只是以事件为单位进行调度。

callback hell

高性能计算

物理世界的空间局部性

```cpp
#pragma omp parallel num_threads(nthread)
#pragma omp for schedule(static)
```

高性能计算中散热可能更麻烦了（

数据中心中的并发

长期的维护工作和高吞吐的请求

协程：和线程类似。但是它会一直执行，直到 `yield()` 才可以放弃 CPU.

Goroutine: 线程和协程的混合。只要发现有很长延迟的操作，如 `sleep` 等等时，把这些操作异步掉，即进行 `yield()`.

go 中的类管道

SIMD

SIMT

## Lec 12 并发 bugs

### 死锁(deadlock)

#### AA-Deadlock

```cpp
lock(&lk);
...
lock(&lk);
```

 通过一定的 `assert` 可以排查。

#### ABBA-Deadlock

死锁产生的必要条件

- Mutual-exclusion

- Wait-for

- No-preemption

- Circular-chain

最简单的方式是防止 circular-chain 的发生。

Lock ordering: 给锁编号。严格按照大小顺序获得锁。

### 数据竞争(data race)

不同线程访问同一个内存，并且至少有一个是写。

这是 UB.

上错锁 or 没上锁是最可能得原因。

### 原子性和顺序违反

代码中被其他操作插入；事件没有按照预定顺序发生。

## Lec 13 应对并发 bugs

软件危机：

- 无法写出所有规约

- 特性的交互组合是指数增长的

### 死锁的应对

lock ordering

运行时检查死锁，数据竞争等等。

可以为每一个线程取得特定锁和释放特定锁时记录日志，构建图。检查是否有环。

对于连续的同一内存，并且没有 happen before 的保证，那么一定会有竞争。

`-fsanitize=thread`

AddressSanitizer(asan): 非法内存访问

ThreadSanitizer(tsan): 数据竞争

...

### 防御性编程

不进行完整的检查，但是实现简单、有用的检查。如 `assert`

Buffer overrun

canary: 用一些额外的内存检查访存越界。

烫烫烫，屯屯屯，葺葺葺

## Lec 14 操作系统上的进程

1. CPU Reset

2. Firmware 运行

3. 加载操作系统

4. 操作系统加载第一个进程

操作系统初始化阶段会开始加载第一个进程。

### fork

创建当前进程的一个完整克隆，父进程得到返回值为子进程的进程号，子进程得到的函数返回值是 0.

如果失败，调用返回值是 -1

Fork Bomb: `:(){:|:&};:`, 即：

```shell
:(){
    : | : & 
};:
```

由于 fork 之间存在父子关系，所以我们自然构造出了进程树。

### execve

重置状态机。把当前进程重置成一个可执行文件描述状态机的初始状态。它是唯一一种能够用来执行程序的系统调用。

创建新状态机的方式： fork + execve

### _exit

立即摧毁状态机，但允许有一个返回值。

调用 c 语言库中的 `exit(n)` 都是 normal exit. syscall 的 `_exit()` 就不一定了。

## Lec 15 进程的地址空间

RTFM: 进程地址空间以及权限。

地址空间就是带有访问权限的内存段。

Memory Map: 在状态机状态上增加，删除，或修改一段内存(mmap, munmap 等)

### 入侵进程地址空间

e.g gdb, perf...

允许一个进程访问指定其他进程的内存？

Game Genie: 直接添加了一个 Look-up Table(LUT)

地址空间中，到底哪一部分才是我们需要修改的内容？

按键精灵 `ydotool`

大语言模型 + 按键精灵

变速齿轮：劫持关于时间的 `syscall`

代码注入

## Lec 16 系统调用和 UNIX Shell

UNIX: Everything is a file. 文件描述符就是指向文件的指针！

Windows 中的 handle(句柄)

管道：一个特殊的文件(stream).它有一个读口和一个写口。读口支持 `read`, 写口支持 `write`.

命名 pipe 和 匿名 pipe

匿名管道创建时会返回读口和写口给对应进程。这一点当 fork 的时候就会派上用场。这可以实现父子进程之间的通信。

管道是进程间的一种同步机制。写并非是单纯的写，直到另一端读出数据后才结束。

### Shell

Command-line interface

UNIX Shell 实际上就是一种编程语言。

man sh

重定向也是先建立管道，再应用 sudo 等等。

## Lec 17 C 标准库设计与实现

C 语言可以看做是系统调用的一层浅封装！

`musl libc`

libc 基础功能是实现基础计算的一些封装。

系统调用和环境的抽象。

动态内存管理

在系统中，不太考虑最坏的情况。

malloc 管理的对象：有小有大。小对象生存周期可长可短。在实现中，一般管理好小对象即可。

Fast path, Slow path

## Lec 18 Linux 操作系统

Minix

Linux Kernel 实际也是加载了一个 init 进程。

update-initramfs: 加载必要的驱动等等，挂载文件系统。

抽象是逐层构建起来的。

systemd 开始配置文件系统。

## Lec 19 可执行文件和加载

### 可执行文件

操作系统中的对象，是一个字节序列，描述了状态机初始状态。

elf: 不是人类友好的状态机描述。是 Linux 的主要可执行文件格式。

a.out 功能太少

代码、符号、重定位

预编译

ELF: 把多段字节复制到地址空间中，并且赋予对应的一些权限。然后，把 PC 跳转到指定位置。

## Lec 20 动态链接和加载

实现运行库和应用程序的分离

库依赖也是一种代码克隆

"Dependency hell"

如果只有静态链接，那么每次更新都很麻烦（

两种实现方式：

- 加载时完成重定位。问题是没省内存，且解析量大。

- 编译器生成位置无关代码，调用时要查表。

进程地址空间通过分页机制维护出表面连续的假象

global offset table(GOT):给每一个需要动态链接的符号留下了一个地址的位置。

函数调用该怎么处理？

- 每次调用都查表？

- 直接把地址写进代码？（可能跳不过去）

PLT(Procedure Linkage Table):检查是不是在动态链接下生成，小跳大跳解决。

## Lec 21 系统调用，中断，上下文切换

OS = 对象 + API

`LD_PRELOAD`

### 系统调用指令

syscall: 跳转，并且获得无限的权力

### 中断

操作系统具有开关中断的权限。

中断：封存状态机，然后执行操作系统代码。

保存寄存器现场->调度->恢复寄存器现场

## Lec 22 进程

通过一个地址转化，把 VPN(virtual address) 转换为 PFN(Physical Address).

virtual page number + offset -> physical page number + offset

地址映射实现：

内存： Radix Tree(32-bit: 1024 叉树；64-bit: 512 叉树 原因：正好 4kB)

处理器： CR3

Translation-Lookaside Buffer(TLB): 处理器部分

Inverted Page Table

所有进程共享的 hash table, 以虚拟地址和进程号进行 hash

Demand Paging

```cpp
fork();
if(...) {
    execve();
}
```

这样很浪费！

fork() 后直接把父子进程的地址空间标记成只读。如果任一进程决定使用它，那么就复制一份。

copy on write

### UNIX

Robert Morris

## Lec 23 处理器调度

操作系统在中断后，可以选择任何进程执行。

trampoline: 用于状态准备的一小段跳转代码。

资源调度？

建模，预测，决策

niceness

UNIX niceness: 越 nice, 就越同意让其他人获得 CPU 资源。这是很古早的机制了。如果 nice 值相同，会使用公平分享的方式， Round-Robin.

动态优先级(MLFQ): 设计了一个带有优先级的队列。如果愿意让出 CPU, 比如 vim 等（在IO），可以变得 nicer 等等。

目前的 linux 是 Complete Fair Scheduling，为每个进程运行的时间进行准确记录。

problem: 互斥怎么办？

目前的解决方式：不解决

signum

SINGKILL

## Lec 25 持久数据存储

DRAM: 电容

持久存储器可以看成是一个巨大的数组，并且允许按照 block 读写。

磁带

磁鼓

磁盘

软盘: 读写性能太差了！

USB, SSD

## Lec 26 输入输出设备

一根线，一条指令

IO设备就是一个能和 CPU 交换数据的接口和控制器的集合

串口(UART)

古早的键盘控制器

ATA

SD 卡

总线：是一个特殊的 IO 设备。它把设备进行了虚拟化，执行对应的注册和转发。从而 CPU 只要连一根总线即可。目前的是 PCI 总线。

中断控制器：收集各个设备的中断，并且选择一个发送给 CPU

DMA(Direct Memory Access): 只能执行 memcpy 的处理器。

GPU

PPU

## Lec 27 文件和设备驱动

### 文件和文件描述符

文件就是有名字的一个对象。

文件描述符就是指向操作系统对象的指针。

访问文件： syscall

“虚拟磁盘”

SIGBUS

offset

文件描述符在 fork 后的行为？

ioctl

## Lec 28 文件系统

top $\to$ down 的分类

Windows 中，一个驱动器建立一棵树。 UNIX 和 Linux 则认为万物皆文件。

UNIX 设计的是目录树进行拼接。

mount: 把一个目录解析为另一个文件系统的根。

回环设备

mkdir

rm -rf *

rmdir

getdents 返回 count 个目录项

硬链接：允许一个文件被多个目录引用

软链接：符号链接

磁盘上的数据结构

bread, bwrite

链表存储数据

FAT

## Lec 29

持久数据

RAID

consistency

崩溃的一致性

FSCK

日志

# 
