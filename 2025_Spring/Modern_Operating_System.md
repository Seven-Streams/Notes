# 现代操作系统

## 第一章 引论

内核态和用户态：操作系统运行在内核态，对所有硬件有完全访问权。

操作系统有两个功能：

- 提供抽象

- 管理硬件（主要是多路复用，包括时间和空间）

大多数总线都是共享总线架构。因此，需要通过仲裁器决定谁使用总线。

PCIe 总线取代了之前的 PCI 总线。PCIe 采用串行总线架构，而 PCI 采用并行总线架构。

这里所谓的串行，指的是单个数据是串行传输的；并行指的是单个数据通过多个数据通路发送，这对精确性等要求高，时延长。PCIe 的时延更短。

### 操作系统的基本概念

**进程**(process)：本质上是一个程序。进程有对应的**地址空间**(address space, 亦被称为 core image)

和进程相关的所有信息，都会存在操作系统的一张表中，即**进程表**(process table)中。

进程间通信：interprocess communication.

工作目录(working directory): 每个进程有一个工作目录。若没有给出绝对地址，那么会在该目录下寻找。

文件描述符(file descriptor): 打开文件后检查其权限。如果权限许可，那么返回一个小整数。这个整数称为文件描述符。

管道(pipe): 一种虚文件。连接两个进程。

rwx 位

进程标识符(Process IDentifier, PID). fork() 父进程返回值为子进程 PID, 子进程返回值为 0.

mount 调用可以把目录挂载到别的位置下面。

## 第二章 进程与线程

### 进程

守护进程(daemon): 在后台停留的进程。当请求到达时唤醒并进行处理。

进程创建：系统初始化，系统调用 fork() 等。

父进程和子进程具有不同的地址空间。有时也会共享。此时为 copy on write.

进程退出：可能是自愿退出(无论是正常退出还是出错退出)；也可能是非自愿退出(严重错误，或者被其他进程杀死)。

UNIX 中，每一个进程都和它所有的子进程组成一个进程组。 init 进程会在系统初始化时被拉起。所有进程都可以看做是 init 进程的后裔进程。

在 Windows 中，进程的继承关系就可以被转移。父进程通过**句柄**与子进程交互。但其一旦把句柄转给另一个进程，继承关系就被转移。

进程的状态：

- 运行态

- 就绪态(可以运行，但是 CPU 被占用)

- 阻塞态

调度程序需要对不同状态的进程的处理进行转移。

进程表：每个进程占用一个进程表项。保证该进程可以直接从阻塞态和就绪态转移到运行态。

interrupt vector

多道程序设计： CPU 利用率 $= 1-p^n$

### 线程

传统中，一个进程包含一个地址空间和一个控制线程。在一个地址空间下，准并行地执行多个控制线程。

线程的好处：

- 利于通信

- 易于创建和摧毁

- 如果多个线程并非 CPU 密集型任务，那么就可以提高效率

线程之间也会不断切换，从而看上去在并行执行。比如 PC, 寄存器, 堆栈, 状态都会由线程来保存。

每个进程也应该存有一份线程表。

两种线程实现方式：在用户空间中和在内核中实现。

如果线程在用户空间中实现，那么内核只需要像单线程进程那样就可以了。

如果线程在内核中实现，那么线程的创建与摧毁也需要进行系统调用。需要与线程有关的调用都不得不进行系统调用。

还有一种方式是尝试进行混合的实现。

多个用户级线程对应一个内核线程。具体多少都由程序员。

### 进程间通信(IPC)

竞争条件(race condition)

临界区(critical region, critical section)

需要阻止对共享内存的同时读写：互斥(mutual exclusion)

- 中断屏蔽

- 自旋锁:自旋过程中 CPu 的空转称为忙等待(busy waiting). 这种策略只适合于等待时间较短的情况。不然性能浪费严重。

- Peterson 算法

- TSL(test and set lock)执行 TSL 后的 CPU 会锁住内存总线，并且禁止其他 CPU 在本指令结束之前访问内存。

- XCHG

信号量、互斥量、条件变量

屏障(barrier):可以用于进行一组线程的同步。直到所有要求的线程都达到了屏障，才会一起被释放。

无锁化：读-复制-更新(Read-Copy-Update, RCU).在一定的宽限期后，旧数据才不再可能被读到。

### 调度

- 计算密集型任务

- I/O密集型任务

三种不同的环境：

- 批处理

- 交互式

- 实时

不同的环境的要求不同。比如，批处理环境追求更高的 CPU 利用率。交互式环境要求最小的响应时间。实时环境要求来到的请求尽量满足截止时间。

#### 批处理环境

- first-come, first-served

- shortest job first

- shortest remaining time next

#### 交互环境

- round robing（轮转调度，但上下文切换也需要时间）

- 优先级调度

- CTSS(Compatible Time Sharing System, 多级队列，每次运行后下移优先级，但是分配的时间片长度翻倍)

- 最短进程优先

- 保证调度(尽量保证一定的性能)

- lottery scheduling(彩票调度，摇奖，可以给更重要的进程更高的优先级)

- 公平调度，每个用户分配到的 CPU 时间相同

#### 实时环境

- hard real time(硬实时，必须达到 DDL)

- soft real time(软实时，允许偶尔错失 DDL)
